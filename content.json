[{"title":"黑马旅游网项目总结","date":"2020-10-31T07:20:03.974Z","path":"2020/10/31/黑马旅游网项目总结/","text":"黑马旅游网项目总结，主要是巩固javaweb的知识，基本全部都运用上了。1 BaseSerlvet的学习做到后面，发现每实现一个功能就要写一个servlet，太多serlvet反而不好，我们想要有关数据库的一张表就对应一个servlet,所以我们引入了BaseServlet,BaseServlet继承HttpServlet,然后让实际实现功能的servlet继承BaseServlet，BaseServlet的service方法很重要，负责分配执行继承BaseServlet的Servlet的方法，应用了反射机制，获取了所有方法，请求哪个方法，就执行哪个方法。 1234567891011121314151617protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //1 获取请求路径 String uri=request.getRequestURI(); //2 获取方法名称 String methodName= uri.substring(uri.lastIndexOf(\"/\")+1); //3 获取方法对象 try &#123; Method method=this.getClass().getMethod(methodName, HttpServletRequest.class,HttpServletResponse.class); method.invoke(this,request,response); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; 2 注册功能 (1)前端在用户名和密码邮箱等等属性校验成功后，才能发起表单提交。将表单系列化，弄成键：值这种形式。返回的json数据，如果flag=true,就跳转激活邮件页面，失败则提醒用户。 1234567891011121314//表单异步提交$(\"#registerForm\").submit(function () &#123; if (checkUsername() &amp;&amp; checkPassword() &amp;&amp; checkEmail()) &#123; $.post(\"user/regist\", $(this).serialize(), function (data) &#123; if(data.flag)&#123; location.href=\"register_ok.html\"; &#125;else&#123; $(\"#Error_msg\").html(data.errorMsg); &#125; &#125;); &#125; return false;&#125;); （2）后端UserSerlvet的regist方法接到请求后 ​ （1）获取所有的参数集合 ​ （2）封装User对象 ​ （3）注册（返回flag） ​ 查找用户名是否存在 ​ 存在直接返回false ​ 不存在则存储用户，发邮件 ​ 用户可以根据邮件信息http://localhost:8080/user/active?code=+user.getCode()去请 求，如果根据激活码查询用户，用户不存在，返回错误信息，存在则更新激活状态。跳转登录界面 ​ （4）返回json数据 ​ resultInfo的三个数据 123private boolean flag;//后端返回结果正常为true，发生异常返回falseprivate Object data;//后端返回结果数据对象private String errorMsg;//发生异常的错误消息 ​ 前端根据flag=ture去跳转激活页面，false就显示错误信息 2 登录功能 （1）前端给登录按钮添加点击事件，一点击就发送表单提交，异步请求。 1234567891011$(\"#btn_sub\").click(function () &#123; $.get(\"user/login\",$(\"#loginForm\").serialize(),function (data) &#123; if(data.flag)&#123; location.href=\"index.html\"; &#125;else&#123; $(\"#errorMsg\").html(data.errorMsg); &#125; &#125;)&#125;) (2)后端UserServlet的login方法 ​ （1）获取参数 ​ （2）封装User ​ (3)根据用户名和密码查询数据库有没有存在该用户， ​ User==null ———封装resultInfo ​ User！=null ​ 查询激活码true -&gt;将user存到session中，封装resultInfo ​ 查询激活码false ——封装resultInfo (3)返回json数据(后面会在BasesServlet中封装成一个方法) 123ObjectMapper mapper=new ObjectMapper();response.setContentType(\"application/json;charset=utf-8\");mapper.writeValue(response.getOutputStream(),info); （4）前端根据flag=true,跳转首页，false显示错误信息。 (3)欢迎姓名（1）前端异步请求，查询是否有用户登录 12345$.get(\"user/findOneName\",&#123;&#125;,function (data) &#123; var msg=\"欢迎回来！\"+data.username; $(\"#span_username\").html(msg);&#125;); (2)后端UserServlet的findOneName()接到请求后， 1234User user= (User) request.getSession().getAttribute(\"user\"); ObjectMapper mapper=new ObjectMapper();response.setContentType(\"application/json;charset=utf-8\");mapper.writeValue(response.getOutputStream(),user); (3)前端接受到数据，就将姓名显示出来 (4)分页显示数据 （1）CategoryServlet的findAll()查询，返回list集合,返回给前端 123456789101112131415161718192021222324@Overridepublic List&lt;Category&gt; findAll() &#123; Jedis jedis = JedisUtil.getJedis(); // Set&lt;String&gt; category=jedis.zrange(\"category\",0,-1); Set&lt;Tuple&gt; category = jedis.zrangeWithScores(\"category\", 0, -1); List&lt;Category&gt; list = null; if (category == null || category.size() == 0) &#123; System.out.println(\"数据库查询\"); list = categorydao.findAll(); for (int i = 0; i &lt; list.size(); i++) &#123; jedis.zadd(\"category\", list.get(i).getCid(), list.get(i).getCname()); &#125; &#125; else &#123; System.out.println(\"redis查询\"); list = new ArrayList&lt;Category&gt;(); for (Tuple tuple : category) &#123; Category category1 = new Category(); category1.setCname(tuple.getElement()); category1.setCid((int)tuple.getScore()); list.add(category1); &#125; &#125; return list;&#125; （2）前端拿到list后 123456789$.get(\"category/findAll\",&#123;&#125;,function (data) &#123; var lis='&lt;li class=\"nav-active\"&gt;&lt;a href=\"index.html\"&gt;首页&lt;/a&gt;&lt;/li&gt;'; for(var i=0;i&lt;data.length;i++)&#123; var li='&lt;li&gt;&lt;a href=\"route_list.html?cid='+data[i].cid+'\"&gt;'+data[i].cname+'&lt;/a&gt;&lt;/li&gt;'; lis+=li; &#125; lis+='&lt;li&gt;&lt;a href=\"favoriterank.html\"&gt;收藏排行榜&lt;/a&gt;&lt;/li&gt;'; $(\"#category\").html(lis);&#125;); 5 分页查询 （1）首先先封装pageBean对象 12345private int totalCount; //总记录数private int totalPage; //总页数private int currentPage; //当前页数private int pageSize; //每页显示的记录数private List&lt;T&gt; list; //list集合 （2）后端Route/pageQuery方法，返回PageBean给前端 12345678910111213141516171819202122232425262728public void pageQuery(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String Page=request.getParameter(\"currentPage\"); //当前页码 String PageSize=request.getParameter(\"PageSize\");//每页显示的记录数 String cid=request.getParameter(\"cid\"); String rname=request.getParameter(\"rname\"); //处理参数 int currentPage=0; if(Page!=null&amp;&amp;Page.length()&gt;0)&#123; currentPage=Integer.parseInt(Page); &#125;else&#123; currentPage=1; &#125; int pageSize=0; if(PageSize!=null&amp;&amp; PageSize.length()&gt;0)&#123; pageSize=Integer.parseInt(PageSize); &#125;else&#123; pageSize=5; &#125; int cid1=0; //这个防止cid为空时异常，Cid为空时，cid1=0,在后面就不会拼接sql语句，就是在全局搜索了 if(cid!=null&amp;&amp; cid.length()&gt;0&amp;&amp;!\"null\".equals(cid))&#123; cid1=Integer.parseInt(cid); &#125; //rname不能=null,否则不参加拼接sql语句 PageBean&lt;Route&gt;pb=service.findAllByPage(currentPage,pageSize,cid1,rname); writeValue(pb,response);&#125; （3）前端拿到数据后， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192$(function () &#123; var cid=getParameter(\"cid\"); var rname=getParameter(\"rname\"); if(rname)&#123; rname=window.decodeURIComponent(rname); &#125; load(cid,null,rname);&#125;);function load(cid,currentPage,rname) &#123; $.get(\"route/pageQuery\",&#123;cid:cid,currentPage:currentPage,rname:rname&#125;,function (pb) &#123; $(\"#totalCount\").html(pb.totalCount); $(\"#totalPage\").html(pb.totalPage); var lis=\"\"; lis+='&lt;li onclick=\"load('+cid+',1,\\''+rname+'\\')\"&gt;&lt;a href=\"javascript:void(0);\"&gt;首页&lt;/a&gt;&lt;/li&gt;'; var page=pb.currentPage-1; if(page&lt;1)&#123; page=1; &#125; lis+='&lt;li class=\"threeword\" onclick=\"load('+cid+','+page+',\\''+rname+'\\')\"&gt;&lt;a href=\"javascript:void(0);\"&gt;上一页&lt;/a&gt;&lt;/li&gt;'; //只显示10个页码 var begin; var end; if(pb.totalPage&lt;10)&#123; begin=1; end=pb.totalPage; &#125; else&#123; begin=pb.currentPage-5; end=pb.currentPage+4; if(begin&lt;1)&#123; begin=1; end=begin+9; &#125; if(end&gt;pb.totalPage)&#123; begin=pb.totalPage-9; end=pb.totalPage; &#125; &#125; for (let i = begin; i &lt;=end ; i++) &#123; if(i==pb.currentPage)&#123; var li='&lt;li class=\"curPage\" onclick=\"load('+cid+','+i+',\\''+rname+'\\')\"&gt;&lt;a href=\"javascript:void(0);\"&gt;'+i+'&lt;/a&gt;&lt;/li&gt;'; &#125;else&#123; var li='&lt;li onclick=\"load('+cid+','+i+',\\''+rname+'\\')\"&gt;&lt;a href=\"javascript:void(0)\"&gt;'+i+'&lt;/a&gt;&lt;/li&gt;'; &#125; lis+=li; &#125; page=pb.currentPage+1; if(page&gt;pb.totalPage)&#123; page=pb.totalPage; &#125; lis+='&lt;li class=\"threeword\" onclick=\"load('+cid+','+page+',\\''+rname+'\\')\"&gt;&lt;a href=\"javascript:void(0);\"&gt;下一页&lt;/a&gt;&lt;/li&gt;'; lis+='&lt;li class=\"threeword\" onclick=\"load('+cid+','+pb.totalPage+',\\''+rname+'\\')\"&gt;&lt;a href=\"javascript:void(0);\"&gt;末页&lt;/a&gt;&lt;/li&gt;'; $(\"#pageNumber\").html(lis); //list集合展示 var route_lis=\"\"; for (let i = 0; i &lt;pb.list.length ; i++) &#123; var route=pb.list[i]; var li=' &lt;li&gt;\\n' + ' &lt;div class=\"img\"&gt;&lt;img style=\"width:299px;\" src=\"'+route.rimage+'\"&gt;&lt;/div&gt;\\n' + ' &lt;div class=\"text1\"&gt;\\n' + ' &lt;p&gt;'+route.rname+'&lt;/p&gt;\\n' + ' &lt;br/&gt;\\n' + ' &lt;p&gt;'+route.routeIntroduce+'&lt;/p&gt;\\n' + ' &lt;/div&gt;\\n' + ' &lt;div class=\"price\"&gt;\\n' + ' &lt;p class=\"price_num\"&gt;\\n' + ' &lt;span&gt;&amp;yen;&lt;/span&gt;\\n' + ' &lt;span&gt;'+route.price+'&lt;/span&gt;\\n' + ' &lt;span&gt;起&lt;/span&gt;\\n' + ' &lt;/p&gt;\\n' + ' &lt;p&gt;&lt;a href=\"route_detail.html?rid='+route.rid+'\"&gt;查看详情&lt;/a&gt;&lt;/p&gt;\\n' + ' &lt;/div&gt;\\n' + ' &lt;/li&gt;'; route_lis+=li; &#125; $(\"#list\").html(route_lis); window.scrollTo(0,0);//每换一次页码，都会回到页面顶端 &#125;);&#125; 6 收藏功能 1.前端发送异步请求，提交rid,返回Route对象 1234567891011121314151617181920212223242526272829303132 var rid = getParameter(\"rid\"); $.get(\"route/findDetail\", &#123;rid: rid&#125;, function (route) &#123; $(\"#rname\").html(route.rname); $(\"#price\").html(\"￥\"+route.price); $(\"#routeIntroduce\").html(route.routeIntroduce); $(\"#sname\").html(route.seller.sname); $(\"#consphone\").html(route.seller.consphone); $(\"#address\").html(route.seller.address);$(\"#love\").html(\"已收藏\"+route.count+\"次\"); var lis=' &lt;a class=\"up_img up_img_disable\"&gt;&lt;/a&gt;'; //遍历图片集合 for (let i = 0; i &lt;route.routeImgList.length ; i++) &#123; var a; if(i&lt;4)&#123; a=' &lt;a title=\"\" class=\"little_img\"\\n' + ' data-bigpic=\"'+route.routeImgList[i].bigPic+'\"&gt;\\n' + ' &lt;img src=\"'+route.routeImgList[i].smallPic+'\"&gt;\\n' + ' &lt;/a&gt;'; &#125;else&#123; a=' &lt;a title=\"\" class=\"little_img\"\\n' + ' data-bigpic=\"'+route.routeImgList[i].bigPic+'\"\\n' + ' style=\"display:none;\"&gt;\\n' + ' &lt;img src=\"'+route.routeImgList[i].smallPic+'\"&gt;\\n' + ' &lt;/a&gt;'; &#125; lis+=a; &#125; lis+='&lt;a class=\"down_img down_img_disable\" style=\"margin-bottom: 0;\"&gt;&lt;/a&gt;'; $(\"#dd\").html(lis); 前端提交异步请求，是否收藏 1234567891011//收藏 $.get(\"route/isFavorite\",&#123;rid:rid&#125;,function (flag) &#123; if(flag)&#123; //用户收藏 $(\"#favorite\").addClass(\"already\"); $(\"#favorite\").attr(\"disabled\",\"disabled\"); $(\"#favorite\").removeAttr(\"onclick\"); &#125; &#125;);&#125;); 给收藏按钮绑定点击事件 1234567891011121314function shoucang() &#123; var rid=getParameter(\"rid\"); $.get(\"user/findOneName\",&#123;&#125;,function (user) &#123; if(user)&#123; //用户登录了 $.get(\"route/addFavorite\",&#123;rid:rid&#125;,function () &#123; location.reload(); &#125;); &#125;else&#123; alert(\"你尚未登录！请登录\"); location.href='login.html'; &#125; &#125;);","comments":true,"tags":[{"name":"Javaweb","slug":"Javaweb","permalink":"http://yoursite.com/tags/Javaweb/"}]},{"title":"如何用hexo搭建个人博客","date":"2020-10-27T00:48:08.306Z","path":"2020/10/27/如何用hexo搭建个人博客/","text":"本文写于：2020 年 4 月 1 号 ，总结我的搭建博客过程 首先说一下 我搭建个人博客的目的，学习总会碰到很多问题，这时候我们需要一个平台去记录我们的解决问题的过程，陪伴我们变强秃头。我也是一个小白开始的，github,git,hexo 是什么，干什么的都不清楚，就是对这些概念很模糊。然后在网上找了很多视频、文章,按着教程来，过程肯定会出错，毕竟是小白，出错了我们就要解决，不要怕，怕是没用的。所有的错误解决了，就会很有成就感。下面是搭建个人博客的过程。我的电脑是 window 10，64bit。 一：前期准备————注册 github 账号，下载 git，node.js1.注册 github 账号：可以前去https://www.github.com注册，点击右上角的 sign up,输入用户名，绑定你的邮箱，输入你的密码，即可完成注册。 2.下载 git:前往https://gitforwindows.org/,点击 download，选择你电脑型号的下载。3.node.js:前往https://nodejs.org/en/ 二：开始配置1.前往 git 文件夹下，右键打开 git bash——-相当于 Linux 的终端，输入 12git config --global user.name \"username\"git config --global user.email \"your mail\" username 就是你注册 github 账号名字，your mail 就是注册 github 时绑定的邮箱。 2.安装 hexo 不要在晚上时安装，因为 github 晚上的访问很慢，所以会出错——我踩过的坑 前往 git 文件夹，右键打开 git bash,输入 1npm install -g hexo-cli 3.初始化 hexo 123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 就是一个存放站点文件的文件夹，可以建在任意地方，用 cd 命令转至其它地方，我是直接在建在 git 文件夹下，方便查找。所以可以直接输入 123hexo init Myblogcd Myblognpm install 这时候 git 文件夹会生成 Myblog 文件夹。 4.在本地打开博客网站 在站点文件夹下运行 git bash,输入 hexo serer(hexo s),当出现下面的图片，就证明我们可以在本地打开我们的博客网站了。 输入网址：localhost:4000 即可访问我的博客，刚开始博客主题就是这样的，后期我们可以更改。 三:将博客部署到 github 上（所有命令都要在站点文件夹下 Myblog 运行 git bash）1.new repository(仓库):仓库名格式一定是：你的用户名.github.io 2.安装 hexo-deployer-git 插件 1npm install hexo-deployer-git --save 3.创建 SSH key 1ssh-keygen -t rsa -C \"your mail\" 会出现这样，意思是输入你 github 密码，再输入一遍 4.复制 id_rsa.pub 文件的内容 前往 C:\\用户\\用户名.ssh\\id_rsa.pub,用记事本打开 id_rsa.pub，复制里面的内容。 5.在 github new SSH key 点击头像、setting、SSH and GPG keys,右上角点击 new SSH key, tittle:用户名.github.io 文本框粘贴刚刚赋值的东西 6.修改博客配置 前往站点文件夹(Myblog),用记事本打开.config.yml 文件，找到如下图位置，修改。 1234deploy: type: git repo: git@github.com:Chengzhaoyong/Chengzhaoyong.github.io.git branch: master 注意：冒号后面有一个空格 6.推送到 github 12hexo g 生成静态文件，每写一篇博客，都要执行hexo d 部署到github仓库 这时候我们就可以通过用户名.github.io 访问我们的博客了，我们已经成功搭建好博客了。 四：主题更换——yilia1.在站点文件夹（Myblog）运行 git bash ,输入 1git clone git://github.com/litten/hexo-theme-yilia.git themes/yilia 在 Myblog 文件夹下的 themes 文件夹就会有一个 yilia 文件夹 2.前往站点文件夹(Myblog),用记事本打开.config.yml 文件，找到如下图位置，修改。 1theme:yilia 3.运行命令 12hexo g 重新生成静态文件hexo d 重新部署到github 4.输入用户名.github.io，就可以看到我们的博客主题换了。 参考如下： 微信公众号：漫游前段世界 https://mp.weixin.qq.com/s/qSMGf0p-ypDMuCtt1qsDIQ B 站视频 CodeSheep:https://www.bilibili.com/video/BV1Yb411a7ty?from=search&amp;seid=10401211365557430754","comments":true,"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"java.lang.ClassNotFoundException com.fasterxml.jackson.databind.ObjectMapper的解决方法【IDEA】","date":"2020-10-20T15:45:56.528Z","path":"2020/10/20/java.lang.ClassNotFoundException com.fasterxml.jackson.databind.ObjectMapper的解决方法【IDEA】/","text":"java.lang.ClassNotFoundException: com.fasterxml.jackson.databind.ObjectMapper的解决方法【IDEA】解决办法：1.按住ctrl，鼠标左键点ObjectMapper ，打开了依赖的jar包。发现文件最上面出现download…的字样，点击下载。2.耐心等下载完成。完成后，file选项卡打开project structure…3.如图： 参考：https://blog.csdn.net/NewObjectMe/article/details/103196178","comments":true,"tags":[{"name":"Javaweb","slug":"Javaweb","permalink":"http://yoursite.com/tags/Javaweb/"}]},{"title":"参照性导致插入顺序改变","date":"2020-05-23T08:41:18.363Z","path":"2020/05/23/参照性导致插入顺序改变/","text":"最近一次数据库作业，往Course表中插入数据，报错了，花了好久才弄明白。都是被参照性坑的。 定义Course表中有一段这样代码 12FOREIGN KEY(Cpno) REFERENCES Course(Cno) //表级完整性约束，Cpno是外码，被参照表是自己 ---就是这个坑，参照表是自己 所以，先行课要先存在数据库中的表中，我才能插入（先行课已经存在表中）的课程。因此就要要求插入顺序了，正确地顺序应该是这样子 先插入先行课为空的课程，再按照存在的课程2、6，找到先行课为2、6的课程插入，以此类推 总结：课程的先行课要在表中存在，课程才能插入成功","comments":true,"tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"解决hexo框架支持latex数学公式","date":"2020-05-23T08:19:57.449Z","path":"2020/05/23/解决hexo框架支持latex数学公式/","text":"2020/5/23 最近操作系统学习有点难，都要计算什么的，所以要用到数学公式记录笔记，但是hexo next主题默认渲染不支持latex的数学公式。所以今天就要解决这个问题。 1 安装Kramedhexo 的默认渲染引擎是marked，但是marded不支持latex公式，所以要更换hexo的渲染引擎为Kramed。在自己博客目录下开启git bash,分别输入 12npm uninstall hexo-renderer-marked -- savenpm install hexo-renderer-kramed --save 2 更改krame下的文件配置进入/node_modules/hexo-renderer-kramed/lib/renderer.js，将formatText函数返回值更改 3 下载mathjax包（所有命令都在个人博客目录下输入）先卸载math包 1npm uninstall hexo-math --save 安装mathjax包 1npm install hexo-renderer-mathjax --save 4 更改mathjax的配置打开 /node_modules/hexo-renderer-mathjax/mathjax.html==，复制一下内容到html文件最后一行，并把原来的script注释掉 1&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"&gt;&lt;/script&gt; 5 更改默认转义规则由于latex与markdown语法有语义冲突，所以要修改默认的规则 打开/node_modules\\kramed\\lib\\rules\\inline.js，将原来escape,em的注释掉，重新写。 6 开启mathjax在主题文件夹下，打开config.yml文件，找到 1mathjax: false 修改为 1mathjax: true 注意：无论是配置文件还是博客文件，配置项跟配置参数均有有一个空格，否则会配置失败。如果你的博客文章要使用latex公式，在YAML Front Matter添加配置项 1mathjax: true 参考： https://www.jianshu.com/p/68e6f82d88b7","comments":true,"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Junit单元测试、反射、注解","date":"2020-05-20T14:05:54.818Z","path":"2020/05/20/Junit单元测试、反射、注解/","text":"今日内容1. Junit单元测试 2. 反射 3. 注解 Junit单元测试：* 测试分类： 1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值。 2. 白盒测试：需要写代码的。关注程序具体的执行流程。 * Junit使用：白盒测试 * 步骤： 1. 定义一个测试类(测试用例) * 建议： * 测试类名：被测试的类名Test CalculatorTest * 包名：xxx.xxx.xx.test cn.itcast.test 2. 定义测试方法：可以独立运行 * 建议： * 方法名：test测试的方法名 testAdd() * 返回值：void * 参数列表：空参 3. 给方法加@Test 4. 导入junit依赖环境 * 判定结果： * 红色：失败 * 绿色：成功 * 一般我们会使用断言操作来处理结果 * Assert.assertEquals(期望的结果,运算的结果); * 补充： * @Before: * 修饰的方法会在测试方法之前被自动执行 * @After: * 修饰的方法会在测试方法执行之后自动被执行 反射：框架设计的灵魂* 框架：半成品软件。可以在框架的基础上进行软件开发，简化编码 * 反射：将类的各个组成部分封装为其他对象，这就是反射机制 * 好处： 1. 可以在程序运行过程中，操作这些对象。 2. 可以解耦，提高程序的可扩展性。 * 获取Class对象的方式： 1. Class.forName(&quot;全类名&quot;)：将字节码文件加载进内存，返回Class对象 * 多用于配置文件，将类名定义在配置文件中。读取文件，加载类 2. 类名.class：通过类名的属性class获取 * 多用于参数的传递 3. 对象.getClass()：getClass()方法在Object类中定义着。 * 多用于对象的获取字节码的方式 * 结论： 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。 * Class对象功能： * 获取功能： 1. 获取成员变量们 * Field[] getFields() ：获取所有public修饰的成员变量 * Field getField(String name) 获取指定名称的 public修饰的成员变量 * Field[] getDeclaredFields() 获取所有的成员变量，不考虑修饰符 * Field getDeclaredField(String name) 2. 获取构造方法们 * Constructor&lt;?&gt;[] getConstructors() * Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes) * Constructor&lt;?&gt;[] getDeclaredConstructors() 3. 获取成员方法们： * Method[] getMethods() * Method getMethod(String name, 类&lt;?&gt;... parameterTypes) * Method[] getDeclaredMethods() * Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes) 4. 获取全类名 * String getName() * Field：成员变量 * 操作： 1. 设置值 * void set(Object obj, Object value) 2. 获取值 * get(Object obj) 3. 忽略访问权限修饰符的安全检查 * setAccessible(true):暴力反射 * Constructor:构造方法 * 创建对象： * T newInstance(Object... initargs) * 如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法 * Method：方法对象 * 执行方法： * Object invoke(Object obj, Object... args) * 获取方法名称： * String getName:获取方法名 * 案例： * 需求：写一个&quot;框架&quot;，不能改变该类的任何代码的前提下，可以帮我们创建任意类的对象，并且执行其中任意方法 * 实现： 1. 配置文件 2. 反射 * 步骤： 1. 将需要创建的对象的全类名和需要执行的方法定义在配置文件中 2. 在程序中加载读取配置文件 3. 使用反射技术来加载类文件进内存 4. 创建对象 5. 执行方法 注解：* 概念：说明程序的。给计算机看的 * 注释：用文字描述程序的。给程序员看的 * 定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 * 概念描述： * JDK1.5之后的新特性 * 说明程序的 * 使用注解：@注解名称 ​​ * 作用分类：​ ①编写文档：通过代码里标识的注解生成文档【生成文档doc文档】​ ②代码分析：通过代码里标识的注解对代码进行分析【使用反射】​ ③编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】 * JDK中预定义的一些注解 * @Override ：检测被该注解标注的方法是否是继承自父类(接口)的 * @Deprecated：该注解标注的内容，表示已过时 * @SuppressWarnings：压制警告 * 一般传递参数all @SuppressWarnings(&quot;all&quot;) * 自定义注解 * 格式： 元注解 public @interface 注解名称{ 属性列表; } * 本质：注解本质上就是一个接口，该接口默认继承Annotation接口 * public interface MyAnno extends java.lang.annotation.Annotation {} * 属性：接口中的抽象方法 * 要求： 1. 属性的返回值类型有下列取值 * 基本数据类型 * String * 枚举 * 注解 * 以上类型的数组 2. 定义了属性，在使用时需要给属性赋值 1. 如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。 2. 如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。 3. 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略 * 元注解：用于描述注解的注解 * @Target：描述注解能够作用的位置 * ElementType取值： * TYPE：可以作用于类上 * METHOD：可以作用于方法上 * FIELD：可以作用于成员变量上 * @Retention：描述注解被保留的阶段 * @Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到 * @Documented：描述注解是否被抽取到api文档中 * @Inherited：描述注解是否被子类继承 * 在程序使用(解析)注解：获取注解中定义的属性值 1. 获取注解定义的位置的对象 （Class，Method,Field） 2. 获取指定的注解 * getAnnotation(Class) //其实就是在内存中生成了一个该注解接口的子类实现对象 public class ProImpl implements Pro{ public String className(){ return &quot;cn.itcast.annotation.Demo1&quot;; } public String methodName(){ return &quot;show&quot;; } } 3. 调用注解中的抽象方法获取配置的属性值 * 案例：简单的测试框架 * 小结： 1. 以后大多数时候，我们会使用注解，而不是自定义注解 2. 注解给谁用？ 1. 编译器 2. 给解析程序用 3. 注解不是程序的一部分，可以理解为注解就是一个标签","comments":true,"tags":[{"name":"Javaweb","slug":"Javaweb","permalink":"http://yoursite.com/tags/Javaweb/"}]},{"title":"分页、分段、段页式存储系统（操作系统）","date":"2020-04-27T03:33:46.170Z","path":"2020/04/27/分页、分段、段页式存储系统（操作系统）/","text":"2020/4/27 在家的网课，无聊，记录一下分页，分段，段页式存储笔记 昨天刚学了分页存储，听得我一脸懵逼，好在课下花了很长时间才弄懂。 1 分页存储管理1.分页存储管理方式分页存储管理是解决存储碎片的一种方法。动态重定位是解决存储碎片问题的一种途径，但要移动大量信息从而浪费处理机时间,代价比较高,这是因为这种分配要求把作业必须安置在一连续存储区内的缘故,而分页存储管理正是要避开这种连续性要求。 2.页面相对物理块来说，页是逻辑地址空间（虚拟内存空间）的划分，是逻辑地址空间顺序等分而成的一段逻辑空间，并依次连续编号。页的大小一般为 512B~8KB。 例如：一个 32 位的操作系统，页的大小设为 2^{12}=4kb，那么就有页号从 0 编到$2^{20}$的那么多页逻辑空间。 3.物理块物理块则是相对于虚拟内存对物理内存按顺序等大小的划分。物理块的大小需要与页的大小一致。 例如：$2^{31}$ =2Gb 的物理内存，按照 4Kb/页的大小划分，可以划分成物理块号从 0 到 $2^{19}$ 的那么多块的物理内存空间。 4.例题答案：2 B34H 3F7B34H 首先将逻辑地址化为二进制：0010 1011 0011 0100页面大小是4k,也就是要用$2^{12}$个位表示,后面12位表示页内地址，前面4位表示页号，0010也就是十进制2,1011 0011 0100化为十六进制就是B34H，物理地址=页面大小物理块大小+页内地址。所以3F7H\\4K+B34H,3F7H*4k也就是逻辑左移12位，后面加12个0，B34H二进制刚好是12位，直接加在后面，也就是3F7B34H。 这道题都是十进制，也要化为二进制。 首先将1A68化为二进制：0001 1010 0110 1000页面大小是1k,也就是要用$2^{10}$个位表示,后面12位表示页内地址，前面6位表示页号，000110也就是十进制6,，6号对应的物理块是31，31化为二进制011111，物理地址=页面大小*物理块大小+页内地址。011111逻辑左移10位，后面加10个0，再加上10 0110 1000十位，等于0111 1110 0110 1000，化为16进制7E68H。 总结：这类题都是逻辑地址化为二进制，看页面大小，确定前面多少位表示页号和后面多少位表示页内地址。然后物理地址等于物理块二进制*页面大小二进制，也就是物理块二进制逻辑左移几位，再加上内页地址的二进制，最后化为16进制。 再看一下这道题 2 分段管理1 分段管理的引入 方便编程：通常一个作业是由多个程序段和数据段组成的，一般情况下，用户希望按逻辑关系对作业分段，并能根据名字来访问程序段和数据段。 信息共享：（1）共享是以信息的逻辑单位为基础的。页是存储信息的物理单位，段却是信息的逻辑单位。 ​ （2）式管理中地址空间是一维的，主程序，子程序都顺序排列， 共享公用子程序比较困难，一个共享过程可能需要几十个页面。 信息保护：（1）页式管理中，一个页面中可能装有 2 个不同的子程序段的指令代码，不能通过页面共享实现共享一个逻辑上完整的子程序或数据块。 ​ （2）段式管理中，可以以信息的逻辑单位进行保护。 动态增长：实际应用中，某些段（数据段）会不断增长，前面的存储管理方法均难以实现。 动态链接：动态链接在程序运行时才把主程序和要用到的目标程序（程序段）链接起来。 2 地址变换机构 越界：如果段号&gt;段表长度TL，就是分段越界，如果段内地址&gt;该段的段长SL，就是段内越界。 2 例题 解析： 碎片是指内存中无法利用的存储空间，碎片分为内部碎片和外部碎片，内部碎片是指分配给作业的存储空间中未被利用的部分，外部碎片是指系统中无法利用的小存储块。 在分页存储管理系统中，作业地址空间划分成若干大小相等的页，相应地将内存的存储空间分成与页大小相等的块，在为作业分配存储空间时，总是以块为单位来分配，可以将作业中的某一页放到内存的某一空闲块中。在分页存储管理中，要求将作业放在一片连续的存储区域中，因而会产生内存碎片问题。 在分段存储管理系统中，作业的地址空间划分为若干个逻辑分段，每个分段是一组逻辑意义相对完整的信息集合，每个分段都有自己的名字，每个分段都从0开始编址并采用一段连续的地址空间。内存分配以段为单位，每段分配一个连续的内存区，但各段之间不要求连续。分段的大小是由用户所决定的，用户根据需要而划分，需要多少就分配多少，所以不会产生碎片。 在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小固定的页，内存空间分成若干个和页面大小相同的物理块，对内存的分配以物理块为单位，这种存储方式会产生内存碎片问题。 固定分区存储管理方法是最早使用的一种可以运行多道程序的存储管理方法，它将内存空间划分为若干个固定大小的分区，每个分区中可以装入一道程序。分区的大小可以不等，但事先必须确定，在运行时不能改变。这种方法由于作业的大小并不一定与某个分区大小相等，存储空间会被浪费，内存不能得到充分利用。 总结：分页和分段的区别：a)页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于系统管理的需要，而不是用户的需要（也是对用户透明的）。段是信息的逻辑单位，它含有一组其意义相对完整的信息（比如数据段、代码段和堆栈段等）。分段的目的是为了能更好的满足用户的需要（用户也是可以使用的）。 b)页的大小固定且由系统确定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面。段的长度却不固定，决定于用户所编写的程序，通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分。 c)分页的作业地址空间是一维的，即单一的线性空间，程序员只须利用一个记忆符（线性地址的16进制表示），即可表示一地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名（比如数据段、代码段和堆栈段等），又需给出段内地址。 d)页和段都有存储保护机制。但存取权限不同：段有读、写和执行三种权限；而页只有读和写两种权限。 3 段页式存储1 段页式存储管理的基本思想段页式存储组织是分段式和分页式结合的存储组织方法，这样可充分利用分段管理和分页管理的优点。 (1) 用分段方法来分配和管理虚拟存储器。程序的地址空间按逻辑单位分成基本独立的段，而每一段有自己的段名，再把每段分成固定大小的若干页。 (2) 用分页方法来分配和管理实存。即把整个主存分成与上述页大小相等的存储块，可装入作业的任何一页。程序对内存的调入或调出是按页进行的。但它又可按段实现共享和保护。 注意：在段页式系统中，为了获得一条指令或数据，必须三次访问内存。第一次访问是访问内存中的段表，从中取得页表地址；第二次访问是访问内存中的页表，从中取出该页所在的物理快好，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正从第二次访问所得的地址中取出指令或数据。 2 例题 参考：https://blog.csdn.net/low5252/article/details/105691077 ​ https://blog.csdn.net/qq_28602957/article/details/53637103","comments":true,"tags":[{"name":"专业课","slug":"专业课","permalink":"http://yoursite.com/tags/%E4%B8%93%E4%B8%9A%E8%AF%BE/"}]},{"title":"网易云网络异常","date":"2020-04-26T13:44:03.737Z","path":"2020/04/26/网易云网络异常/","text":"2020/4/26 网易云网络异常因为开了代理，网易云音乐其实是一个基于网页的软件，软件联网，页面显示都是通过调用系统自带的浏览器IE完成的。 解决方法： 1.按住win+r,输入cmd,然后在输入命令：ipconfig/flushdns,回车此时显示Window IP配置 已成功刷新DNS解析缓存 2.打开IE浏览器，右上角设置，选择Internet 选项，高级，然后重置，就可以了","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"IDEA如何永久激活、安装","date":"2020-04-23T04:17:02.562Z","path":"2020/04/23/IDEA如何永久激活、安装/","text":"2020/4/23,记录我第一次使用IDEA，很好用，就是很吃内存 1.下载文件 此文件在百度网盘，下载即可。 2.双击.exe文件，选择安装路径，然后 只点击第一个就行了，第二第三个点了有点麻烦，害我又重新安装。 3.安装完成后，关闭重启软件，直接next,直到 点击Evaluate,continue就OK了，再次关闭软件。 4.复制jetbrains-agent.jar到没有中文目录文件夹，例如直接复制到c盘根目录双击IDEA，点击configure,选择Edit Custom VM Options,在最后加入一行代码 1-javaagent:C:\\jetbrains-agent.jar 也就是.jar的安装路径要根据你的安装路径修改，这里是直接安装在C盘，然后关闭IDEA。 5.复制许可证打开license.txt,复制全部内容，打开IDEA，还是选择configure,点击Manage license 选择Activation code,粘贴刚才复制的内容，点击Activate,close关闭即可。 6.中文化将文件最后一个.jar复制到IDEA的目录下的lib文件夹下，启动IDEA，就可以看到汉化版的IDEA了。","comments":true,"tags":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6/"}]},{"title":"本地项目如何上传github","date":"2020-04-07T06:17:59.240Z","path":"2020/04/07/本地项目如何上传github/","text":"本文写于2020/04/07 1.在本地的创建一个文件夹，也就是本地用来存储你的项目的仓库。以我为例，snake文件夹，放我这个项目的文件。 进入这个文件夹，运行git bash 这时候，文件夹有个.git文件夹，它是Git用来跟踪和管理版本库对的，如果你看不见，设置一下电脑让隐藏文件课件，百度一下即可 2.将你的项目复制到你创建的文件夹snake下面 3.使用git status 查看你的当前状态 这些文件是红色，说明这些文件处于Git的工作目录，还没有加入暂存区域，使用git add .使这些文件全部加入暂存区域 这时候查看文件的当前状态，发现这些文件都变绿了,说明这些文件已经进入暂存区域 4.提交本地仓库(git commit -m “提交说明”) 5.关联github仓库（SSH我已经有了，本地仓库已经建好的前提） 这时候本地仓库已经做好了，接下来要和github仓库进行关联，为下一步push做准备。 6.将本地项目上传到github仓库 这时候会报错，因为在创建仓库的时候，你勾选了这个选项，github仓库会自动创建一个readme文件，本地仓库没有这个文件，所以报错。 7.使用git pull拉去github的仓库和本地仓库同步(git pull –rebase origin master) 8将本地仓库内容推送到github仓库（git push -u origin master） 这时候刷新一下我们本地仓库，就可以看到我们的仓库多了内容。 参考如下： https://www.cnblogs.com/sylys/p/11961512.html","comments":true,"tags":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"}]}]